{"ast":null,"code":"import _defineProperty from \"D:\\\\salma\\\\FWD web development course\\\\advanced full stack\\\\PROJECT\\\\try\\\\New folder\\\\now\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\defineProperty.js\";\nimport _asyncToGenerator from \"D:\\\\salma\\\\FWD web development course\\\\advanced full stack\\\\PROJECT\\\\try\\\\New folder\\\\now\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport _classCallCheck from \"D:\\\\salma\\\\FWD web development course\\\\advanced full stack\\\\PROJECT\\\\try\\\\New folder\\\\now\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\classCallCheck.js\";\nimport _createClass from \"D:\\\\salma\\\\FWD web development course\\\\advanced full stack\\\\PROJECT\\\\try\\\\New folder\\\\now\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createClass.js\";\nimport _toConsumableArray from \"D:\\\\salma\\\\FWD web development course\\\\advanced full stack\\\\PROJECT\\\\try\\\\New folder\\\\now\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\nimport _regeneratorRuntime from \"D:\\\\salma\\\\FWD web development course\\\\advanced full stack\\\\PROJECT\\\\try\\\\New folder\\\\now\\\\udagram\\\\udagram-frontend\\\\node_modules\\\\@babel\\\\runtime\\\\regenerator\\\\index.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { r as registerInstance, e as createEvent, c as writeTask, h, H as Host, i as getElement } from './index-b3eecb14.js';\nimport { b as getIonMode, c as config } from './ionic-global-0ebe321c.js';\nimport { C as CoreDelegate, a as attachComponent, d as detachComponent } from './framework-delegate-0e9f0224.js';\nimport { k as clamp, g as getElementRoot, r as raf } from './helpers-6e1e5b65.js';\nimport { KEYBOARD_DID_OPEN } from './keyboard-808e4e15.js';\nimport { B as BACKDROP, e as prepareOverlay, d as _present, h as activeAnimations, f as _dismiss, g as eventMethod } from './overlays-36d3475d.js';\nimport { g as getClassMap } from './theme-a24ff1ad.js';\nimport { e as deepReady } from './index-e6c2c822.js';\nimport { c as createAnimation } from './animation-19dbf9bf.js';\nimport { g as getTimeGivenProgression } from './cubic-bezier-154a53a5.js';\nimport { createGesture } from './index-41bf41f2.js';\nimport './hardware-back-button-ace6a71b.js';\nimport './gesture-controller-68c023a4.js'; // Defaults for the card swipe animation\n\nvar SwipeToCloseDefaults = {\n  MIN_PRESENTING_SCALE: 0.93\n};\n\nvar createSwipeToCloseGesture = function createSwipeToCloseGesture(el, animation, onDismiss) {\n  var height = el.offsetHeight;\n  var isOpen = false;\n\n  var canStart = function canStart(detail) {\n    var target = detail.event.target;\n\n    if (target === null || !target.closest) {\n      return true;\n    }\n\n    var contentOrFooter = target.closest('ion-content, ion-footer');\n\n    if (contentOrFooter === null) {\n      return true;\n    } // Target is in the content or the footer so do not start the gesture.\n    // We could be more nuanced here and allow it for content that\n    // does not need to scroll.\n\n\n    return false;\n  };\n\n  var onStart = function onStart() {\n    animation.progressStart(true, isOpen ? 1 : 0);\n  };\n\n  var onMove = function onMove(detail) {\n    var step = clamp(0.0001, detail.deltaY / height, 0.9999);\n    animation.progressStep(step);\n  };\n\n  var onEnd = function onEnd(detail) {\n    var velocity = detail.velocityY;\n    var step = clamp(0.0001, detail.deltaY / height, 0.9999);\n    var threshold = (detail.deltaY + velocity * 1000) / height;\n    var shouldComplete = threshold >= 0.5;\n    var newStepValue = shouldComplete ? -0.001 : 0.001;\n\n    if (!shouldComplete) {\n      animation.easing('cubic-bezier(1, 0, 0.68, 0.28)');\n      newStepValue += getTimeGivenProgression([0, 0], [1, 0], [0.68, 0.28], [1, 1], step)[0];\n    } else {\n      animation.easing('cubic-bezier(0.32, 0.72, 0, 1)');\n      newStepValue += getTimeGivenProgression([0, 0], [0.32, 0.72], [0, 1], [1, 1], step)[0];\n    }\n\n    var duration = shouldComplete ? computeDuration(step * height, velocity) : computeDuration((1 - step) * height, velocity);\n    isOpen = shouldComplete;\n    gesture.enable(false);\n    animation.onFinish(function () {\n      if (!shouldComplete) {\n        gesture.enable(true);\n      }\n    }).progressEnd(shouldComplete ? 1 : 0, newStepValue, duration);\n\n    if (shouldComplete) {\n      onDismiss();\n    }\n  };\n\n  var gesture = createGesture({\n    el: el,\n    gestureName: 'modalSwipeToClose',\n    gesturePriority: 40,\n    direction: 'y',\n    threshold: 10,\n    canStart: canStart,\n    onStart: onStart,\n    onMove: onMove,\n    onEnd: onEnd\n  });\n  return gesture;\n};\n\nvar computeDuration = function computeDuration(remaining, velocity) {\n  return clamp(400, remaining / Math.abs(velocity * 1.1), 500);\n};\n/**\n * Use y = mx + b to\n * figure out the backdrop value\n * at a particular x coordinate. This\n * is useful when the backdrop does\n * not begin to fade in until after\n * the 0 breakpoint.\n */\n\n\nvar getBackdropValueForSheet = function getBackdropValueForSheet(x, backdropBreakpoint) {\n  /**\n   * We will use these points:\n   * (backdropBreakpoint, 0)\n   * (maxBreakpoint, 1)\n   * We know that at the beginning breakpoint,\n   * the backdrop will be hidden. We also\n   * know that at the maxBreakpoint, the backdrop\n   * must be fully visible. maxBreakpoint should\n   * always be 1 even if the maximum value\n   * of the breakpoints array is not 1 since\n   * the animation runs from a progress of 0\n   * to a progress of 1.\n   * m = (y2 - y1) / (x2 - x1)\n   *\n   * This is simplified from:\n   * m = (1 - 0) / (maxBreakpoint - backdropBreakpoint)\n   */\n  var slope = 1 / (1 - backdropBreakpoint);\n  /**\n   * From here, compute b which is\n   * the backdrop opacity if the offset\n   * is 0. If the backdrop does not\n   * begin to fade in until after the\n   * 0 breakpoint, this b value will be\n   * negative. This is fine as we never pass\n   * b directly into the animation keyframes.\n   * b = y - mx\n   * Use a known point: (backdropBreakpoint, 0)\n   * This is simplified from:\n   * b = 0 - (backdropBreakpoint * slope)\n   */\n\n  var b = -(backdropBreakpoint * slope);\n  /**\n   * Finally, we can now determine the\n   * backdrop offset given an arbitrary\n   * gesture offset.\n   */\n\n  return x * slope + b;\n};\n\nvar createSheetEnterAnimation = function createSheetEnterAnimation(opts) {\n  var currentBreakpoint = opts.currentBreakpoint,\n      backdropBreakpoint = opts.backdropBreakpoint;\n  /**\n   * If the backdropBreakpoint is undefined, then the backdrop\n   * should always fade in. If the backdropBreakpoint came before the\n   * current breakpoint, then the backdrop should be fading in.\n   */\n\n  var shouldShowBackdrop = backdropBreakpoint === undefined || backdropBreakpoint < currentBreakpoint;\n  var initialBackdrop = shouldShowBackdrop ? \"calc(var(--backdrop-opacity) * \".concat(currentBreakpoint, \")\") : '0';\n  var backdropAnimation = createAnimation('backdropAnimation').fromTo('opacity', 0, initialBackdrop);\n\n  if (shouldShowBackdrop) {\n    backdropAnimation.beforeStyles({\n      'pointer-events': 'none'\n    }).afterClearStyles(['pointer-events']);\n  }\n\n  var wrapperAnimation = createAnimation('wrapperAnimation').keyframes([{\n    offset: 0,\n    opacity: 1,\n    transform: 'translateY(100%)'\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: \"translateY(\".concat(100 - currentBreakpoint * 100, \"%)\")\n  }]);\n  return {\n    wrapperAnimation: wrapperAnimation,\n    backdropAnimation: backdropAnimation\n  };\n};\n\nvar createSheetLeaveAnimation = function createSheetLeaveAnimation(opts) {\n  var currentBreakpoint = opts.currentBreakpoint,\n      backdropBreakpoint = opts.backdropBreakpoint;\n  /**\n   * Backdrop does not always fade in from 0 to 1 if backdropBreakpoint\n   * is defined, so we need to account for that offset by figuring out\n   * what the current backdrop value should be.\n   */\n\n  var backdropValue = \"calc(var(--backdrop-opacity) * \".concat(getBackdropValueForSheet(currentBreakpoint, backdropBreakpoint), \")\");\n  var defaultBackdrop = [{\n    offset: 0,\n    opacity: backdropValue\n  }, {\n    offset: 1,\n    opacity: 0\n  }];\n  var customBackdrop = [{\n    offset: 0,\n    opacity: backdropValue\n  }, {\n    offset: backdropBreakpoint,\n    opacity: 0\n  }, {\n    offset: 1,\n    opacity: 0\n  }];\n  var backdropAnimation = createAnimation('backdropAnimation').keyframes(backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop);\n  var wrapperAnimation = createAnimation('wrapperAnimation').keyframes([{\n    offset: 0,\n    opacity: 1,\n    transform: \"translateY(\".concat(100 - currentBreakpoint * 100, \"%)\")\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: \"translateY(100%)\"\n  }]);\n  return {\n    wrapperAnimation: wrapperAnimation,\n    backdropAnimation: backdropAnimation\n  };\n};\n\nvar createEnterAnimation$1 = function createEnterAnimation$1() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  var wrapperAnimation = createAnimation().fromTo('transform', 'translateY(100vh)', 'translateY(0vh)');\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * iOS Modal Enter Animation for the Card presentation style\n */\n\n\nvar iosEnterAnimation = function iosEnterAnimation(baseEl, opts) {\n  var presentingEl = opts.presentingEl,\n      currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation$1(),\n      wrapperAnimation = _ref.wrapperAnimation,\n      backdropAnimation = _ref.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({\n    'opacity': 1\n  });\n  var baseAnimation = createAnimation('entering-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(500).addAnimation(wrapperAnimation);\n\n  if (presentingEl) {\n    var isMobile = window.innerWidth < 768;\n    var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n    var presentingElRoot = getElementRoot(presentingEl);\n    var presentingAnimation = createAnimation().beforeStyles({\n      'transform': 'translateY(0)',\n      'transform-origin': 'top center',\n      'overflow': 'hidden'\n    });\n    var bodyEl = document.body;\n\n    if (isMobile) {\n      /**\n       * Fallback for browsers that does not support `max()` (ex: Firefox)\n       * No need to worry about statusbar padding since engines like Gecko\n       * are not used as the engine for standalone Cordova/Capacitor apps\n       */\n      var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n      var modalTransform = hasCardModal ? '-10px' : transformOffset;\n      var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n      var finalTransform = \"translateY(\".concat(modalTransform, \") scale(\").concat(toPresentingScale, \")\");\n      presentingAnimation.afterStyles({\n        'transform': finalTransform\n      }).beforeAddWrite(function () {\n        return bodyEl.style.setProperty('background-color', 'black');\n      }).addElement(presentingEl).keyframes([{\n        offset: 0,\n        filter: 'contrast(1)',\n        transform: 'translateY(0px) scale(1)',\n        borderRadius: '0px'\n      }, {\n        offset: 1,\n        filter: 'contrast(0.85)',\n        transform: finalTransform,\n        borderRadius: '10px 10px 0 0'\n      }]);\n      baseAnimation.addAnimation(presentingAnimation);\n    } else {\n      baseAnimation.addAnimation(backdropAnimation);\n\n      if (!hasCardModal) {\n        wrapperAnimation.fromTo('opacity', '0', '1');\n      } else {\n        var _toPresentingScale = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n\n        var _finalTransform = \"translateY(-10px) scale(\".concat(_toPresentingScale, \")\");\n\n        presentingAnimation.afterStyles({\n          'transform': _finalTransform\n        }).addElement(presentingElRoot.querySelector('.modal-wrapper')).keyframes([{\n          offset: 0,\n          filter: 'contrast(1)',\n          transform: 'translateY(0) scale(1)'\n        }, {\n          offset: 1,\n          filter: 'contrast(0.85)',\n          transform: _finalTransform\n        }]);\n        var shadowAnimation = createAnimation().afterStyles({\n          'transform': _finalTransform\n        }).addElement(presentingElRoot.querySelector('.modal-shadow')).keyframes([{\n          offset: 0,\n          opacity: '1',\n          transform: 'translateY(0) scale(1)'\n        }, {\n          offset: 1,\n          opacity: '0',\n          transform: _finalTransform\n        }]);\n        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n      }\n    }\n  } else {\n    baseAnimation.addAnimation(backdropAnimation);\n  }\n\n  return baseAnimation;\n};\n\nvar createLeaveAnimation$1 = function createLeaveAnimation$1() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  var wrapperAnimation = createAnimation().fromTo('transform', 'translateY(0vh)', 'translateY(100vh)');\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * iOS Modal Leave Animation\n */\n\n\nvar iosLeaveAnimation = function iosLeaveAnimation(baseEl, opts) {\n  var duration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 500;\n  var presentingEl = opts.presentingEl,\n      currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref2 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation$1(),\n      wrapperAnimation = _ref2.wrapperAnimation,\n      backdropAnimation = _ref2.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelectorAll('.modal-wrapper, .modal-shadow')).beforeStyles({\n    'opacity': 1\n  });\n  var baseAnimation = createAnimation('leaving-base').addElement(baseEl).easing('cubic-bezier(0.32,0.72,0,1)').duration(duration).addAnimation(wrapperAnimation);\n\n  if (presentingEl) {\n    var isMobile = window.innerWidth < 768;\n    var hasCardModal = presentingEl.tagName === 'ION-MODAL' && presentingEl.presentingElement !== undefined;\n    var presentingElRoot = getElementRoot(presentingEl);\n    var presentingAnimation = createAnimation().beforeClearStyles(['transform']).afterClearStyles(['transform']).onFinish(function (currentStep) {\n      // only reset background color if this is the last card-style modal\n      if (currentStep !== 1) {\n        return;\n      }\n\n      presentingEl.style.setProperty('overflow', '');\n      var numModals = Array.from(bodyEl.querySelectorAll('ion-modal')).filter(function (m) {\n        return m.presentingElement !== undefined;\n      }).length;\n\n      if (numModals <= 1) {\n        bodyEl.style.setProperty('background-color', '');\n      }\n    });\n    var bodyEl = document.body;\n\n    if (isMobile) {\n      var transformOffset = !CSS.supports('width', 'max(0px, 1px)') ? '30px' : 'max(30px, var(--ion-safe-area-top))';\n      var modalTransform = hasCardModal ? '-10px' : transformOffset;\n      var toPresentingScale = SwipeToCloseDefaults.MIN_PRESENTING_SCALE;\n      var finalTransform = \"translateY(\".concat(modalTransform, \") scale(\").concat(toPresentingScale, \")\");\n      presentingAnimation.addElement(presentingEl).keyframes([{\n        offset: 0,\n        filter: 'contrast(0.85)',\n        transform: finalTransform,\n        borderRadius: '10px 10px 0 0'\n      }, {\n        offset: 1,\n        filter: 'contrast(1)',\n        transform: 'translateY(0px) scale(1)',\n        borderRadius: '0px'\n      }]);\n      baseAnimation.addAnimation(presentingAnimation);\n    } else {\n      baseAnimation.addAnimation(backdropAnimation);\n\n      if (!hasCardModal) {\n        wrapperAnimation.fromTo('opacity', '1', '0');\n      } else {\n        var _toPresentingScale2 = hasCardModal ? SwipeToCloseDefaults.MIN_PRESENTING_SCALE : 1;\n\n        var _finalTransform2 = \"translateY(-10px) scale(\".concat(_toPresentingScale2, \")\");\n\n        presentingAnimation.addElement(presentingElRoot.querySelector('.modal-wrapper')).afterStyles({\n          'transform': 'translate3d(0, 0, 0)'\n        }).keyframes([{\n          offset: 0,\n          filter: 'contrast(0.85)',\n          transform: _finalTransform2\n        }, {\n          offset: 1,\n          filter: 'contrast(1)',\n          transform: 'translateY(0) scale(1)'\n        }]);\n        var shadowAnimation = createAnimation().addElement(presentingElRoot.querySelector('.modal-shadow')).afterStyles({\n          'transform': 'translateY(0) scale(1)'\n        }).keyframes([{\n          offset: 0,\n          opacity: '0',\n          transform: _finalTransform2\n        }, {\n          offset: 1,\n          opacity: '1',\n          transform: 'translateY(0) scale(1)'\n        }]);\n        baseAnimation.addAnimation([presentingAnimation, shadowAnimation]);\n      }\n    }\n  } else {\n    baseAnimation.addAnimation(backdropAnimation);\n  }\n\n  return baseAnimation;\n};\n\nvar createEnterAnimation = function createEnterAnimation() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 0.01, 'var(--backdrop-opacity)').beforeStyles({\n    'pointer-events': 'none'\n  }).afterClearStyles(['pointer-events']);\n  var wrapperAnimation = createAnimation().keyframes([{\n    offset: 0,\n    opacity: 0.01,\n    transform: 'translateY(40px)'\n  }, {\n    offset: 1,\n    opacity: 1,\n    transform: \"translateY(0px)\"\n  }]);\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * Md Modal Enter Animation\n */\n\n\nvar mdEnterAnimation = function mdEnterAnimation(baseEl, opts) {\n  var currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref3 = currentBreakpoint !== undefined ? createSheetEnterAnimation(opts) : createEnterAnimation(),\n      wrapperAnimation = _ref3.wrapperAnimation,\n      backdropAnimation = _ref3.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n  return createAnimation().addElement(baseEl).easing('cubic-bezier(0.36,0.66,0.04,1)').duration(280).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar createLeaveAnimation = function createLeaveAnimation() {\n  var backdropAnimation = createAnimation().fromTo('opacity', 'var(--backdrop-opacity)', 0);\n  var wrapperAnimation = createAnimation().keyframes([{\n    offset: 0,\n    opacity: 0.99,\n    transform: \"translateY(0px)\"\n  }, {\n    offset: 1,\n    opacity: 0,\n    transform: 'translateY(40px)'\n  }]);\n  return {\n    backdropAnimation: backdropAnimation,\n    wrapperAnimation: wrapperAnimation\n  };\n};\n/**\n * Md Modal Leave Animation\n */\n\n\nvar mdLeaveAnimation = function mdLeaveAnimation(baseEl, opts) {\n  var currentBreakpoint = opts.currentBreakpoint;\n  var root = getElementRoot(baseEl);\n\n  var _ref4 = currentBreakpoint !== undefined ? createSheetLeaveAnimation(opts) : createLeaveAnimation(),\n      wrapperAnimation = _ref4.wrapperAnimation,\n      backdropAnimation = _ref4.backdropAnimation;\n\n  backdropAnimation.addElement(root.querySelector('ion-backdrop'));\n  wrapperAnimation.addElement(root.querySelector('.modal-wrapper'));\n  return createAnimation().easing('cubic-bezier(0.47,0,0.745,0.715)').duration(200).addAnimation([backdropAnimation, wrapperAnimation]);\n};\n\nvar createSheetGesture = function createSheetGesture(baseEl, backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, animation) {\n  var breakpoints = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n  var onDismiss = arguments.length > 7 ? arguments[7] : undefined;\n  var onBreakpointChange = arguments.length > 8 ? arguments[8] : undefined;\n  // Defaults for the sheet swipe animation\n  var defaultBackdrop = [{\n    offset: 0,\n    opacity: 'var(--backdrop-opacity)'\n  }, {\n    offset: 1,\n    opacity: 0.01\n  }];\n  var customBackdrop = [{\n    offset: 0,\n    opacity: 'var(--backdrop-opacity)'\n  }, {\n    offset: 1 - backdropBreakpoint,\n    opacity: 0\n  }, {\n    offset: 1,\n    opacity: 0\n  }];\n  var SheetDefaults = {\n    WRAPPER_KEYFRAMES: [{\n      offset: 0,\n      transform: 'translateY(0%)'\n    }, {\n      offset: 1,\n      transform: 'translateY(100%)'\n    }],\n    BACKDROP_KEYFRAMES: backdropBreakpoint !== 0 ? customBackdrop : defaultBackdrop\n  };\n  var contentEl = baseEl.querySelector('ion-content');\n  var height = wrapperEl.clientHeight;\n  var currentBreakpoint = initialBreakpoint;\n  var offset = 0;\n  var wrapperAnimation = animation.childAnimations.find(function (ani) {\n    return ani.id === 'wrapperAnimation';\n  });\n  var backdropAnimation = animation.childAnimations.find(function (ani) {\n    return ani.id === 'backdropAnimation';\n  });\n  var maxBreakpoint = breakpoints[breakpoints.length - 1];\n\n  var enableBackdrop = function enableBackdrop() {\n    baseEl.style.setProperty('pointer-events', 'auto');\n    backdropEl.style.setProperty('pointer-events', 'auto');\n    /**\n     * When the backdrop is enabled, elements such\n     * as inputs should not be focusable outside\n     * the sheet.\n     */\n\n    baseEl.classList.remove('ion-disable-focus-trap');\n  };\n\n  var disableBackdrop = function disableBackdrop() {\n    baseEl.style.setProperty('pointer-events', 'none');\n    backdropEl.style.setProperty('pointer-events', 'none');\n    /**\n     * When the backdrop is enabled, elements such\n     * as inputs should not be focusable outside\n     * the sheet.\n     * Adding this class disables focus trapping\n     * for the sheet temporarily.\n     */\n\n    baseEl.classList.add('ion-disable-focus-trap');\n  };\n  /**\n   * After the entering animation completes,\n   * we need to set the animation to go from\n   * offset 0 to offset 1 so that users can\n   * swipe in any direction. We then set the\n   * animation offset to the current breakpoint\n   * so there is no flickering.\n   */\n\n\n  if (wrapperAnimation && backdropAnimation) {\n    wrapperAnimation.keyframes(_toConsumableArray(SheetDefaults.WRAPPER_KEYFRAMES));\n    backdropAnimation.keyframes(_toConsumableArray(SheetDefaults.BACKDROP_KEYFRAMES));\n    animation.progressStart(true, 1 - currentBreakpoint);\n    /**\n     * If backdrop is not enabled, then content\n     * behind modal should be clickable. To do this, we need\n     * to remove pointer-events from ion-modal as a whole.\n     * ion-backdrop and .modal-wrapper always have pointer-events: auto\n     * applied, so the modal content can still be interacted with.\n     */\n\n    var shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;\n\n    if (shouldEnableBackdrop) {\n      enableBackdrop();\n    } else {\n      disableBackdrop();\n    }\n  }\n\n  if (contentEl && currentBreakpoint !== maxBreakpoint) {\n    contentEl.scrollY = false;\n  }\n\n  var canStart = function canStart(detail) {\n    /**\n     * If the sheet is fully expanded and\n     * the user is swiping on the content,\n     * the gesture should not start to\n     * allow for scrolling on the content.\n     */\n    var content = detail.event.target.closest('ion-content');\n\n    if (currentBreakpoint === 1 && content) {\n      return false;\n    }\n\n    return true;\n  };\n\n  var onStart = function onStart() {\n    /**\n     * If swiping on the content\n     * we should disable scrolling otherwise\n     * the sheet will expand and the content will scroll.\n     */\n    if (contentEl) {\n      contentEl.scrollY = false;\n    }\n\n    raf(function () {\n      /**\n       * Dismisses the open keyboard when the sheet drag gesture is started.\n       * Sets the focus onto the modal element.\n       */\n      baseEl.focus();\n    });\n    animation.progressStart(true, 1 - currentBreakpoint);\n  };\n\n  var onMove = function onMove(detail) {\n    /**\n     * Given the change in gesture position on the Y axis,\n     * compute where the offset of the animation should be\n     * relative to where the user dragged.\n     */\n    var initialStep = 1 - currentBreakpoint;\n    offset = clamp(0.0001, initialStep + detail.deltaY / height, 0.9999);\n    animation.progressStep(offset);\n  };\n\n  var onEnd = function onEnd(detail) {\n    /**\n     * When the gesture releases, we need to determine\n     * the closest breakpoint to snap to.\n     */\n    var velocity = detail.velocityY;\n    var threshold = (detail.deltaY + velocity * 100) / height;\n    var diff = currentBreakpoint - threshold;\n    var closest = breakpoints.reduce(function (a, b) {\n      return Math.abs(b - diff) < Math.abs(a - diff) ? b : a;\n    });\n    var shouldRemainOpen = closest !== 0;\n    currentBreakpoint = 0;\n    /**\n     * Update the animation so that it plays from\n     * the last offset to the closest snap point.\n     */\n\n    if (wrapperAnimation && backdropAnimation) {\n      wrapperAnimation.keyframes([{\n        offset: 0,\n        transform: \"translateY(\".concat(offset * 100, \"%)\")\n      }, {\n        offset: 1,\n        transform: \"translateY(\".concat((1 - closest) * 100, \"%)\")\n      }]);\n      backdropAnimation.keyframes([{\n        offset: 0,\n        opacity: \"calc(var(--backdrop-opacity) * \".concat(getBackdropValueForSheet(1 - offset, backdropBreakpoint), \")\")\n      }, {\n        offset: 1,\n        opacity: \"calc(var(--backdrop-opacity) * \".concat(getBackdropValueForSheet(closest, backdropBreakpoint), \")\")\n      }]);\n      animation.progressStep(0);\n    }\n    /**\n     * Gesture should remain disabled until the\n     * snapping animation completes.\n     */\n\n\n    gesture.enable(false);\n    animation.onFinish(function () {\n      if (shouldRemainOpen) {\n        /**\n         * Once the snapping animation completes,\n         * we need to reset the animation to go\n         * from 0 to 1 so users can swipe in any direction.\n         * We then set the animation offset to the current\n         * breakpoint so that it starts at the snapped position.\n         */\n        if (wrapperAnimation && backdropAnimation) {\n          raf(function () {\n            wrapperAnimation.keyframes(_toConsumableArray(SheetDefaults.WRAPPER_KEYFRAMES));\n            backdropAnimation.keyframes(_toConsumableArray(SheetDefaults.BACKDROP_KEYFRAMES));\n            animation.progressStart(true, 1 - closest);\n            currentBreakpoint = closest;\n            onBreakpointChange(currentBreakpoint);\n            /**\n             * If the sheet is fully expanded, we can safely\n             * enable scrolling again.\n             */\n\n            if (contentEl && currentBreakpoint === breakpoints[breakpoints.length - 1]) {\n              contentEl.scrollY = true;\n            }\n            /**\n             * Backdrop should become enabled\n             * after the backdropBreakpoint value\n             */\n\n\n            var shouldEnableBackdrop = currentBreakpoint > backdropBreakpoint;\n\n            if (shouldEnableBackdrop) {\n              enableBackdrop();\n            } else {\n              disableBackdrop();\n            }\n\n            gesture.enable(true);\n          });\n        } else {\n          gesture.enable(true);\n        }\n      }\n      /**\n       * This must be a one time callback\n       * otherwise a new callback will\n       * be added every time onEnd runs.\n       */\n\n    }, {\n      oneTimeCallback: true\n    }).progressEnd(1, 0, 500);\n\n    if (!shouldRemainOpen) {\n      onDismiss();\n    }\n  };\n\n  var gesture = createGesture({\n    el: wrapperEl,\n    gestureName: 'modalSheet',\n    gesturePriority: 40,\n    direction: 'y',\n    threshold: 10,\n    canStart: canStart,\n    onStart: onStart,\n    onMove: onMove,\n    onEnd: onEnd\n  });\n  return gesture;\n};\n\nvar modalIosCss = \":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--ion-color-step-350, #c0c0be);z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.4)}:host(.modal-card),:host(.modal-sheet){--border-radius:10px}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:10px}}.modal-wrapper{-webkit-transform:translate3d(0,  100%,  0);transform:translate3d(0,  100%,  0)}@media screen and (max-width: 767px){@supports (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - max(30px, var(--ion-safe-area-top)) - 10px)}}@supports not (width: max(0px, 1px)){:host(.modal-card){--height:calc(100% - 40px)}}:host(.modal-card) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-card) .modal-wrapper,:host-context([dir=rtl]).modal-card .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host(.modal-card){--backdrop-opacity:0;--width:100%;-ms-flex-align:end;align-items:flex-end}:host(.modal-card) .modal-shadow{display:none}:host(.modal-card) ion-backdrop{pointer-events:none}}@media screen and (min-width: 768px){:host(.modal-card){--width:calc(100% - 120px);--height:calc(100% - (120px + var(--ion-safe-area-top) + var(--ion-safe-area-bottom)));--max-width:720px;--max-height:1000px;--backdrop-opacity:0;--box-shadow:0px 0px 30px 10px rgba(0, 0, 0, 0.1);-webkit-transition:all 0.5s ease-in-out;transition:all 0.5s ease-in-out}:host(.modal-card) .modal-wrapper{-webkit-box-shadow:none;box-shadow:none}:host(.modal-card) .modal-shadow{-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow)}}:host(.modal-sheet) .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}:host-context([dir=rtl]):host(.modal-sheet) .modal-wrapper,:host-context([dir=rtl]).modal-sheet .modal-wrapper{border-top-left-radius:var(--border-radius);border-top-right-radius:var(--border-radius);border-bottom-right-radius:0;border-bottom-left-radius:0}\";\nvar modalMdCss = \":host{--width:100%;--min-width:auto;--max-width:auto;--height:100%;--min-height:auto;--max-height:auto;--overflow:hidden;--border-radius:0;--border-width:0;--border-style:none;--border-color:transparent;--background:var(--ion-background-color, #fff);--box-shadow:none;--backdrop-opacity:0;left:0;right:0;top:0;bottom:0;display:-ms-flexbox;display:flex;position:absolute;-ms-flex-align:center;align-items:center;-ms-flex-pack:center;justify-content:center;outline:none;contain:strict}.modal-wrapper,ion-backdrop{pointer-events:auto}:host(.overlay-hidden){display:none}.modal-wrapper,.modal-shadow{border-radius:var(--border-radius);width:var(--width);min-width:var(--min-width);max-width:var(--max-width);height:var(--height);min-height:var(--min-height);max-height:var(--max-height);border-width:var(--border-width);border-style:var(--border-style);border-color:var(--border-color);background:var(--background);-webkit-box-shadow:var(--box-shadow);box-shadow:var(--box-shadow);overflow:var(--overflow);z-index:10}.modal-shadow{position:absolute;background:transparent}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--width:600px;--height:500px;--ion-safe-area-top:0px;--ion-safe-area-bottom:0px;--ion-safe-area-right:0px;--ion-safe-area-left:0px}}@media only screen and (min-width: 768px) and (min-height: 768px){:host{--width:600px;--height:600px}}.modal-handle{left:0px;right:0px;top:5px;border-radius:8px;margin-left:auto;margin-right:auto;position:absolute;width:36px;height:5px;-webkit-transform:translateZ(0);transform:translateZ(0);background:var(--ion-color-step-350, #c0c0be);z-index:11}@supports ((-webkit-margin-start: 0) or (margin-inline-start: 0)) or (-webkit-margin-start: 0){.modal-handle{margin-left:unset;margin-right:unset;-webkit-margin-start:auto;margin-inline-start:auto;-webkit-margin-end:auto;margin-inline-end:auto}}:host(.modal-sheet){--height:calc(100% - (var(--ion-safe-area-top) + 10px))}:host(.modal-sheet) .modal-wrapper,:host(.modal-sheet) .modal-shadow{position:absolute;bottom:0}:host{--backdrop-opacity:var(--ion-backdrop-opacity, 0.32)}@media only screen and (min-width: 768px) and (min-height: 600px){:host{--border-radius:2px;--box-shadow:0 28px 48px rgba(0, 0, 0, 0.4)}}.modal-wrapper{-webkit-transform:translate3d(0,  40px,  0);transform:translate3d(0,  40px,  0);opacity:0.01}\";\n\nvar Modal = /*#__PURE__*/function () {\n  function Modal(hostRef) {\n    var _this = this;\n\n    _classCallCheck(this, Modal);\n\n    registerInstance(this, hostRef);\n    this.didPresent = createEvent(this, \"ionModalDidPresent\", 7);\n    this.willPresent = createEvent(this, \"ionModalWillPresent\", 7);\n    this.willDismiss = createEvent(this, \"ionModalWillDismiss\", 7);\n    this.didDismiss = createEvent(this, \"ionModalDidDismiss\", 7);\n    this.didPresentShorthand = createEvent(this, \"didPresent\", 7);\n    this.willPresentShorthand = createEvent(this, \"willPresent\", 7);\n    this.willDismissShorthand = createEvent(this, \"willDismiss\", 7);\n    this.didDismissShorthand = createEvent(this, \"didDismiss\", 7);\n    this.modalIndex = modalIds++;\n    this.coreDelegate = CoreDelegate();\n    this.isSheetModal = false;\n    this.inline = false; // Whether or not modal is being dismissed via gesture\n\n    this.gestureAnimationDismissing = false;\n    this.presented = false;\n    /** @internal */\n\n    this.hasController = false;\n    /**\n     * If `true`, the keyboard will be automatically dismissed when the overlay is presented.\n     */\n\n    this.keyboardClose = true;\n    /**\n     * A decimal value between 0 and 1 that indicates the\n     * point after which the backdrop will begin to fade in\n     * when using a sheet modal. Prior to this point, the\n     * backdrop will be hidden and the content underneath\n     * the sheet can be interacted with. This value is exclusive\n     * meaning the backdrop will become active after the value\n     * specified.\n     */\n\n    this.backdropBreakpoint = 0;\n    /**\n     * If `true`, the modal will be dismissed when the backdrop is clicked.\n     */\n\n    this.backdropDismiss = true;\n    /**\n     * If `true`, a backdrop will be displayed behind the modal.\n     */\n\n    this.showBackdrop = true;\n    /**\n     * If `true`, the modal will animate.\n     */\n\n    this.animated = true;\n    /**\n     * If `true`, the modal can be swiped to dismiss. Only applies in iOS mode.\n     */\n\n    this.swipeToClose = false;\n    /**\n     * If `true`, the modal will open. If `false`, the modal will close.\n     * Use this if you need finer grained control over presentation, otherwise\n     * just use the modalController or the `trigger` property.\n     * Note: `isOpen` will not automatically be set back to `false` when\n     * the modal dismisses. You will need to do that in your code.\n     */\n\n    this.isOpen = false;\n\n    this.configureTriggerInteraction = function () {\n      var trigger = _this.trigger,\n          el = _this.el,\n          destroyTriggerInteraction = _this.destroyTriggerInteraction;\n\n      if (destroyTriggerInteraction) {\n        destroyTriggerInteraction();\n      }\n\n      var triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n\n      if (!triggerEl) {\n        return;\n      }\n\n      var configureTriggerInteraction = function configureTriggerInteraction(trigEl, modalEl) {\n        var openModal = function openModal() {\n          modalEl.present();\n        };\n\n        trigEl.addEventListener('click', openModal);\n        return function () {\n          trigEl.removeEventListener('click', openModal);\n        };\n      };\n\n      _this.destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n\n    this.onBackdropTap = function () {\n      _this.dismiss(undefined, BACKDROP);\n    };\n\n    this.onDismiss = function (ev) {\n      ev.stopPropagation();\n      ev.preventDefault();\n\n      _this.dismiss();\n    };\n\n    this.onLifecycle = function (modalEvent) {\n      var el = _this.usersElement;\n      var name = LIFECYCLE_MAP[modalEvent.type];\n\n      if (el && name) {\n        var ev = new CustomEvent(name, {\n          bubbles: false,\n          cancelable: false,\n          detail: modalEvent.detail\n        });\n        el.dispatchEvent(ev);\n      }\n    };\n  }\n\n  _createClass(Modal, [{\n    key: \"onIsOpenChange\",\n    value: function onIsOpenChange(newValue, oldValue) {\n      if (newValue === true && oldValue === false) {\n        this.present();\n      } else if (newValue === false && oldValue === true) {\n        this.dismiss();\n      }\n    }\n  }, {\n    key: \"onTriggerChange\",\n    value: function onTriggerChange() {\n      this.configureTriggerInteraction();\n    }\n  }, {\n    key: \"swipeToCloseChanged\",\n    value: function swipeToCloseChanged(enable) {\n      if (this.gesture) {\n        this.gesture.enable(enable);\n      } else if (enable) {\n        this.initSwipeToClose();\n      }\n    }\n  }, {\n    key: \"connectedCallback\",\n    value: function connectedCallback() {\n      prepareOverlay(this.el);\n    }\n  }, {\n    key: \"componentWillLoad\",\n    value: function componentWillLoad() {\n      var breakpoints = this.breakpoints,\n          initialBreakpoint = this.initialBreakpoint;\n      /**\n       * If user has custom ID set then we should\n       * not assign the default incrementing ID.\n       */\n\n      this.modalId = this.el.hasAttribute('id') ? this.el.getAttribute('id') : \"ion-modal-\".concat(this.modalIndex);\n      this.isSheetModal = breakpoints !== undefined && initialBreakpoint !== undefined;\n\n      if (breakpoints !== undefined && initialBreakpoint !== undefined && !breakpoints.includes(initialBreakpoint)) {\n        console.warn('[Ionic Warning]: Your breakpoints array must include the initialBreakpoint value.');\n      }\n    }\n  }, {\n    key: \"componentDidLoad\",\n    value: function componentDidLoad() {\n      var _this2 = this;\n\n      /**\n       * If modal was rendered with isOpen=\"true\"\n       * then we should open modal immediately.\n       */\n      if (this.isOpen === true) {\n        raf(function () {\n          return _this2.present();\n        });\n      }\n\n      this.configureTriggerInteraction();\n    }\n    /**\n     * Determines whether or not an overlay\n     * is being used inline or via a controller/JS\n     * and returns the correct delegate.\n     * By default, subsequent calls to getDelegate\n     * will use a cached version of the delegate.\n     * This is useful for calling dismiss after\n     * present so that the correct delegate is given.\n     */\n\n  }, {\n    key: \"getDelegate\",\n    value: function getDelegate() {\n      var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.workingDelegate && !force) {\n        return {\n          delegate: this.workingDelegate,\n          inline: this.inline\n        };\n      }\n      /**\n       * If using overlay inline\n       * we potentially need to use the coreDelegate\n       * so that this works in vanilla JS apps.\n       * If a developer has presented this component\n       * via a controller, then we can assume\n       * the component is already in the\n       * correct place.\n       */\n\n\n      var parentEl = this.el.parentNode;\n      var inline = this.inline = parentEl !== null && !this.hasController;\n      var delegate = this.workingDelegate = inline ? this.delegate || this.coreDelegate : this.delegate;\n      return {\n        inline: inline,\n        delegate: delegate\n      };\n    }\n    /**\n     * Present the modal overlay after it has been created.\n     */\n\n  }, {\n    key: \"present\",\n    value: function () {\n      var _present2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _this3 = this;\n\n        var data, _this$getDelegate, inline, delegate;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this.presented) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                if (!(this.currentTransition !== undefined)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 5;\n                return this.currentTransition;\n\n              case 5:\n                data = Object.assign(Object.assign({}, this.componentProps), {\n                  modal: this.el\n                });\n                _this$getDelegate = this.getDelegate(true), inline = _this$getDelegate.inline, delegate = _this$getDelegate.delegate;\n                _context.next = 9;\n                return attachComponent(delegate, this.el, this.component, ['ion-page'], data, inline);\n\n              case 9:\n                this.usersElement = _context.sent;\n                _context.next = 12;\n                return deepReady(this.usersElement);\n\n              case 12:\n                writeTask(function () {\n                  return _this3.el.classList.add('show-modal');\n                });\n                this.currentTransition = _present(this, 'modalEnter', iosEnterAnimation, mdEnterAnimation, {\n                  presentingEl: this.presentingElement,\n                  currentBreakpoint: this.initialBreakpoint,\n                  backdropBreakpoint: this.backdropBreakpoint\n                });\n                _context.next = 16;\n                return this.currentTransition;\n\n              case 16:\n                if (this.isSheetModal) {\n                  this.initSheetGesture();\n                } else if (this.swipeToClose) {\n                  this.initSwipeToClose();\n                }\n                /* tslint:disable-next-line */\n\n\n                if (typeof window !== 'undefined') {\n                  this.keyboardOpenCallback = function () {\n                    if (_this3.gesture) {\n                      /**\n                       * When the native keyboard is opened and the webview\n                       * is resized, the gesture implementation will become unresponsive\n                       * and enter a free-scroll mode.\n                       *\n                       * When the keyboard is opened, we disable the gesture for\n                       * a single frame and re-enable once the contents have repositioned\n                       * from the keyboard placement.\n                       */\n                      _this3.gesture.enable(false);\n\n                      raf(function () {\n                        if (_this3.gesture) {\n                          _this3.gesture.enable(true);\n                        }\n                      });\n                    }\n                  };\n\n                  window.addEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n                }\n\n                this.currentTransition = undefined;\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function present() {\n        return _present2.apply(this, arguments);\n      }\n\n      return present;\n    }()\n  }, {\n    key: \"initSwipeToClose\",\n    value: function initSwipeToClose() {\n      var _this4 = this;\n\n      if (getIonMode(this) !== 'ios') {\n        return;\n      } // All of the elements needed for the swipe gesture\n      // should be in the DOM and referenced by now, except\n      // for the presenting el\n\n\n      var animationBuilder = this.leaveAnimation || config.get('modalLeave', iosLeaveAnimation);\n      var ani = this.animation = animationBuilder(this.el, {\n        presentingEl: this.presentingElement\n      });\n      this.gesture = createSwipeToCloseGesture(this.el, ani, function () {\n        /**\n         * While the gesture animation is finishing\n         * it is possible for a user to tap the backdrop.\n         * This would result in the dismiss animation\n         * being played again. Typically this is avoided\n         * by setting `presented = false` on the overlay\n         * component; however, we cannot do that here as\n         * that would prevent the element from being\n         * removed from the DOM.\n         */\n        _this4.gestureAnimationDismissing = true;\n\n        _this4.animation.onFinish( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return _this4.dismiss(undefined, 'gesture');\n\n                case 2:\n                  _this4.gestureAnimationDismissing = false;\n\n                case 3:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        })));\n      });\n      this.gesture.enable(true);\n    }\n  }, {\n    key: \"initSheetGesture\",\n    value: function initSheetGesture() {\n      var _this5 = this;\n\n      var _a;\n\n      var wrapperEl = this.wrapperEl,\n          initialBreakpoint = this.initialBreakpoint,\n          backdropBreakpoint = this.backdropBreakpoint;\n\n      if (!wrapperEl || initialBreakpoint === undefined) {\n        return;\n      }\n\n      var animationBuilder = this.enterAnimation || config.get('modalEnter', iosEnterAnimation);\n      var ani = this.animation = animationBuilder(this.el, {\n        presentingEl: this.presentingElement,\n        currentBreakpoint: initialBreakpoint,\n        backdropBreakpoint: backdropBreakpoint\n      });\n      ani.progressStart(true, 1);\n      var sortedBreakpoints = ((_a = this.breakpoints) === null || _a === void 0 ? void 0 : _a.sort(function (a, b) {\n        return a - b;\n      })) || [];\n      this.gesture = createSheetGesture(this.el, this.backdropEl, wrapperEl, initialBreakpoint, backdropBreakpoint, ani, sortedBreakpoints, function () {\n        /**\n         * While the gesture animation is finishing\n         * it is possible for a user to tap the backdrop.\n         * This would result in the dismiss animation\n         * being played again. Typically this is avoided\n         * by setting `presented = false` on the overlay\n         * component; however, we cannot do that here as\n         * that would prevent the element from being\n         * removed from the DOM.\n         */\n        _this5.gestureAnimationDismissing = true;\n\n        _this5.animation.onFinish( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return _this5.dismiss(undefined, 'gesture');\n\n                case 2:\n                  _this5.gestureAnimationDismissing = false;\n\n                case 3:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        })));\n      }, function (breakpoint) {\n        _this5.currentBreakpoint = breakpoint;\n      });\n      this.gesture.enable(true);\n    }\n    /**\n     * Dismiss the modal overlay after it has been presented.\n     *\n     * @param data Any data to emit in the dismiss events.\n     * @param role The role of the element that is dismissing the modal. For example, 'cancel' or 'backdrop'.\n     */\n\n  }, {\n    key: \"dismiss\",\n    value: function () {\n      var _dismiss2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(data, role) {\n        var _this6 = this;\n\n        var enteringAnimation, dismissed, _this$getDelegate2, delegate;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (!(this.gestureAnimationDismissing && role !== 'gesture')) {\n                  _context4.next = 2;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", false);\n\n              case 2:\n                /* tslint:disable-next-line */\n                if (typeof window !== 'undefined' && this.keyboardOpenCallback) {\n                  window.removeEventListener(KEYBOARD_DID_OPEN, this.keyboardOpenCallback);\n                }\n                /**\n                 * When using an inline modal\n                 * and presenting a modal it is possible to\n                 * quickly dismiss the modal while it is\n                 * presenting. We need to await any current\n                 * transition to allow the present to finish\n                 * before dismissing again.\n                 */\n\n\n                if (!(this.currentTransition !== undefined)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                _context4.next = 6;\n                return this.currentTransition;\n\n              case 6:\n                enteringAnimation = activeAnimations.get(this) || [];\n                this.currentTransition = _dismiss(this, data, role, 'modalLeave', iosLeaveAnimation, mdLeaveAnimation, {\n                  presentingEl: this.presentingElement,\n                  currentBreakpoint: this.currentBreakpoint || this.initialBreakpoint,\n                  backdropBreakpoint: this.backdropBreakpoint\n                });\n                _context4.next = 10;\n                return this.currentTransition;\n\n              case 10:\n                dismissed = _context4.sent;\n\n                if (!dismissed) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                _this$getDelegate2 = this.getDelegate(), delegate = _this$getDelegate2.delegate;\n                _context4.next = 15;\n                return detachComponent(delegate, this.usersElement);\n\n              case 15:\n                writeTask(function () {\n                  return _this6.el.classList.remove('show-modal');\n                });\n\n                if (this.animation) {\n                  this.animation.destroy();\n                }\n\n                if (this.gesture) {\n                  this.gesture.destroy();\n                }\n\n                enteringAnimation.forEach(function (ani) {\n                  return ani.destroy();\n                });\n\n              case 19:\n                this.currentTransition = undefined;\n                this.animation = undefined;\n                return _context4.abrupt(\"return\", dismissed);\n\n              case 22:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function dismiss(_x, _x2) {\n        return _dismiss2.apply(this, arguments);\n      }\n\n      return dismiss;\n    }()\n    /**\n     * Returns a promise that resolves when the modal did dismiss.\n     */\n\n  }, {\n    key: \"onDidDismiss\",\n    value: function onDidDismiss() {\n      return eventMethod(this.el, 'ionModalDidDismiss');\n    }\n    /**\n     * Returns a promise that resolves when the modal will dismiss.\n     */\n\n  }, {\n    key: \"onWillDismiss\",\n    value: function onWillDismiss() {\n      return eventMethod(this.el, 'ionModalWillDismiss');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _Object$assign,\n          _this7 = this;\n\n      var handle = this.handle,\n          isSheetModal = this.isSheetModal,\n          presentingElement = this.presentingElement,\n          htmlAttributes = this.htmlAttributes;\n      var showHandle = handle !== false && isSheetModal;\n      var mode = getIonMode(this);\n      var modalId = this.modalId;\n      var isCardModal = presentingElement !== undefined && mode === 'ios';\n      return h(Host, Object.assign({\n        \"no-router\": true,\n        \"aria-modal\": \"true\",\n        tabindex: \"-1\"\n      }, htmlAttributes, {\n        style: {\n          zIndex: \"\".concat(20000 + this.overlayIndex)\n        },\n        class: Object.assign((_Object$assign = {}, _defineProperty(_Object$assign, mode, true), _defineProperty(_Object$assign, 'modal-default', !isCardModal && !isSheetModal), _defineProperty(_Object$assign, \"modal-card\", isCardModal), _defineProperty(_Object$assign, \"modal-sheet\", isSheetModal), _defineProperty(_Object$assign, 'overlay-hidden', true), _Object$assign), getClassMap(this.cssClass)),\n        id: modalId,\n        onIonBackdropTap: this.onBackdropTap,\n        onIonDismiss: this.onDismiss,\n        onIonModalDidPresent: this.onLifecycle,\n        onIonModalWillPresent: this.onLifecycle,\n        onIonModalWillDismiss: this.onLifecycle,\n        onIonModalDidDismiss: this.onLifecycle\n      }), h(\"ion-backdrop\", {\n        ref: function ref(el) {\n          return _this7.backdropEl = el;\n        },\n        visible: this.showBackdrop,\n        tappable: this.backdropDismiss,\n        part: \"backdrop\"\n      }), mode === 'ios' && h(\"div\", {\n        class: \"modal-shadow\"\n      }), h(\"div\", {\n        role: \"dialog\",\n        class: \"modal-wrapper ion-overlay-wrapper\",\n        part: \"content\",\n        ref: function ref(el) {\n          return _this7.wrapperEl = el;\n        }\n      }, showHandle && h(\"div\", {\n        class: \"modal-handle\",\n        part: \"handle\"\n      }), h(\"slot\", null)));\n    }\n  }, {\n    key: \"el\",\n    get: function get() {\n      return getElement(this);\n    }\n  }], [{\n    key: \"watchers\",\n    get: function get() {\n      return {\n        \"isOpen\": [\"onIsOpenChange\"],\n        \"trigger\": [\"onTriggerChange\"],\n        \"swipeToClose\": [\"swipeToCloseChanged\"]\n      };\n    }\n  }]);\n\n  return Modal;\n}();\n\nvar LIFECYCLE_MAP = {\n  'ionModalDidPresent': 'ionViewDidEnter',\n  'ionModalWillPresent': 'ionViewWillEnter',\n  'ionModalWillDismiss': 'ionViewWillLeave',\n  'ionModalDidDismiss': 'ionViewDidLeave'\n};\nvar modalIds = 0;\nModal.style = {\n  ios: modalIosCss,\n  md: modalMdCss\n};\nexport { Modal as ion_modal };","map":null,"metadata":{},"sourceType":"module"}